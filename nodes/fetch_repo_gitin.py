"""
EnlightenAI - Fetch Repository Node using gitin

This module contains the FetchRepoGitinNode class, which is responsible for
fetching files from a GitHub repository using the gitin package and storing them in the shared context.
"""

import os
import tempfile
import subprocess
from fnmatch import fnmatch
from nodes import Node
import requests
import base64
from urllib.parse import urlparse
import subprocess
import tempfile


class FetchRepoGitinNode(Node):
    """Node for fetching files from a GitHub repository using gitin."""
    
    def process(self, context):
        """Fetch files from the GitHub repository specified in the context using gitin.
        
        Args:
            context (dict): The shared context dictionary containing:
                - repo_url: The GitHub repository URL
                - include_patterns: List of file patterns to include
                - exclude_patterns: List of file patterns to exclude
                - verbose: Whether to print verbose output
                
        Returns:
            None: The context is updated directly with the fetched files.
        """
        repo_url = context["repo_url"]
        include_patterns = context["include_patterns"]
        exclude_patterns = context["exclude_patterns"]
        verbose = context.get("verbose", False)
        
        if verbose:
            print(f"Fetching repository: {repo_url}")
            print(f"Include patterns: {include_patterns}")
            print(f"Exclude patterns: {exclude_patterns}")
        
        # Create a temporary file to store the gitin output
        with tempfile.NamedTemporaryFile(suffix='.md', delete=False) as temp_file:
            temp_output_path = temp_file.name
        
        try:
            # Prepare the gitin command
            include_arg = ",".join(include_patterns) if include_patterns else "*"
            exclude_arg = ",".join(exclude_patterns) if exclude_patterns else ""
            
            cmd = ["gitin", repo_url, "-o", temp_output_path]
            
            if include_arg:
                cmd.extend(["--include", include_arg])
            
            if exclude_arg:
                cmd.extend(["--exclude", exclude_arg])
            
            # Run gitin to fetch the repository
            if verbose:
                print(f"Running command: {' '.join(cmd)}")
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                raise Exception(f"gitin failed: {result.stderr}")
            
            # Parse the markdown file to extract file contents
            files = self._parse_gitin_output(temp_output_path, verbose)
            
            # Update the context with the files
            context["files"] = files
            
            if verbose:
                print(f"Fetched {len(files)} files from {repo_url}")
            
        finally:
            # Clean up the temporary file
            if os.path.exists(temp_output_path):
                os.unlink(temp_output_path)
        
        # Return None as we've updated the context directly
        return None
    
    def _parse_gitin_output(self, markdown_path, verbose=False):
        """Parse the gitin output markdown file to extract file contents.
        
        Args:
            markdown_path (str): Path to the markdown file generated by gitin
            verbose (bool, optional): Whether to print verbose output
            
        Returns:
            dict: Dictionary mapping file paths to file contents
        """
        files = {}
        current_file = None
        content_lines = []
        
        with open(markdown_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        in_code_block = False
        
        for line in lines:
            # Check for file headers (typically formatted as "### path/to/file.ext")
            if line.startswith('### '):
                # If we were processing a file, save it
                if current_file and content_lines:
                    files[current_file] = ''.join(content_lines)
                    content_lines = []
                
                # Extract the new file path
                current_file = line.strip('# \n')
                if verbose:
                    print(f"Found file in gitin output: {current_file}")
                
            # Check for code block markers
            elif line.strip() == '```' or line.strip().startswith('```'):
                in_code_block = not in_code_block
                # Skip the code block markers
                continue
            
            # If we're in a code block and have a current file, collect the content
            elif in_code_block and current_file:
                content_lines.append(line)
        
        # Don't forget the last file
        if current_file and content_lines:
            files[current_file] = ''.join(content_lines)
        
        return files
